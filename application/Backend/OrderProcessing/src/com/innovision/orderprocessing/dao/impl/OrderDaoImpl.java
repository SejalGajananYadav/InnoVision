package com.innovision.orderprocessing.dao.impl;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import com.innovision.orderprocessing.dao.OrderDao;
import com.innovision.orderprocessing.exception.ConnectionNotEstablishedException;
import com.innovision.orderprocessing.exception.InvalidOrderDateException;
import com.innovision.orderprocessing.exception.InvalidOrderDetailException;
import com.innovision.orderprocessing.exception.NoPendingOrderException;
import com.innovision.orderprocessing.exception.ProductUnavailableException;
import com.innovision.orderprocessing.model.Customer;
import com.innovision.orderprocessing.model.Order;
import com.innovision.orderprocessing.model.Product;

public class OrderDaoImpl implements OrderDao, AutoCloseable {

	private List<Order> orderList = new ArrayList<>();
	private Map<Product, Integer> productList = new HashMap<>();
	private double totalOrderValue = 0.0;
	private double shippingCost = 0.0;
	private Connection con;

	// constructor calls the init method internally
	public OrderDaoImpl() throws ConnectionNotEstablishedException {
		try {
			Class.forName("com.mysql.cj.jdbc.Driver");
			con = DriverManager.getConnection("jdbc:mysql://localhost:3306/OrderProcessing", "root", "@Abc123");
		} catch (SQLException | ClassNotFoundException e) {
			throw new ConnectionNotEstablishedException();
		}
	}

	/*
	 * this method shows all the orders having the status pending and customerId is
	 * equal to cutomer details pass create the list of such orders and send it to
	 * the customer.
	 */
	@Override
	public List<Order> getAllPendingOrder(Customer customer) throws NoPendingOrderException {
		try {
			PreparedStatement pstmt1 = con.prepareStatement(
					"Select o.OrderID,o.OrderDate,o.CustomerID,o.CustomerShippingAddress,o.TotalOrderValue,o.ShippingCost,o.ShippingAgency,o.Status from Customers c natural join Orders o natural join Quote q where CustomerID = ? and o.Status='Pending'");
			pstmt1.setInt(1, customer.getCustomerId());
			ResultSet rs = pstmt1.executeQuery();
			while (rs.next()) {
				int orderId = rs.getInt(1);
				Date new_orderDate = new Date(rs.getDate(2).getTime());
				int new_customerId = rs.getInt(3);
				String new_shippingAddress = rs.getString(4);
				double new_totalOrderValue = rs.getDouble(5);
				double new_shippingCost = rs.getDouble(6);
				String new_shippingAgency = rs.getString(7);
				String new_status = rs.getString(8);
				Order order = new Order(new_orderDate, new_customerId, new_shippingAddress);
				order.setOrderId(orderId);
				order.setTotalOrderValue(new_totalOrderValue);
				order.setShippingCost(new_shippingCost);
				order.setStatus(new_status);
				order.setShippingAgency(new_shippingAgency);
				orderList.add(order);

			}

			return orderList;

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			throw new NoPendingOrderException("There are no pending orders");
		}

	}

	/*
	 * this method updates the totalOrderValue , shipping cost , status of the order
	 * based on the products added in the order and order is approved or not
	 */
	@Override
	public void update(Order order) throws InvalidOrderDetailException {
		// TODO Auto-generated method stub
		try {
			PreparedStatement pstmt1 = con
					.prepareStatement("Update Orders set TotalOrderValue=? , ShippingCost=?,Status=? where OrderId=?");
			pstmt1.setDouble(1, this.calculateTotalOrderValue(order));
			pstmt1.setDouble(2, this.calculateShippingCost(order));
			pstmt1.setString(3, order.getStatus());
			pstmt1.setInt(4, order.getOrderId());
			pstmt1.executeUpdate();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			throw new InvalidOrderDetailException("Invalid Order Details");
		}
	}

	/*
	 * This method adds the order details in the Orders table and fetch the
	 * autogenerated orderId and assign to the order object
	 */
	@Override
	public void insertOrder(Order order) throws InvalidOrderDetailException {
		// TODO Auto-generated method stub

		try {
			PreparedStatement pstmt = con.prepareStatement(
					"Insert into Orders(OrderDate,CustomerId,CustomerShippingAddress,TotalOrderValue,ShippingCost,ShippingAgency,Status) values(?,?,?,?,?,?,?) ",
					Statement.RETURN_GENERATED_KEYS);
			pstmt.setDate(1, new java.sql.Date(order.getOrderDate().getTime()));
			pstmt.setInt(2, order.getCustomerId());
			pstmt.setString(3, order.getCustomerAddress());
			pstmt.setDouble(4, order.getTotalOrderValue());
			pstmt.setDouble(5, order.getShippingCost());
			pstmt.setString(6, order.getShippingAgency());
			pstmt.setString(7, order.getStatus());
			pstmt.executeUpdate();
			ResultSet generatedKeys = pstmt.getGeneratedKeys();
			if (generatedKeys.next()) {
				int orderId = generatedKeys.getInt(1);
				order.setOrderId(orderId);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			throw new InvalidOrderDetailException("Invalid Order Details");
		}

	}

	/*
	 * this method adds the product and their respective count to the hashmap
	 * productlist where the product object is key and quantity is value.and also
	 * updates the totatordervalue as per the product price and quantity.
	 */
	@Override
	public void addProduct(Product product, int quantity) {
		this.productList.put(product, quantity);
		this.totalOrderValue += (product.getPrice() * quantity);
	}

	@Override
	public Map<Product, Integer> getProductList() {
		return productList;
	}

	/*
	 * this products adds the entry inside the table OrderProducts which represents
	 * the many to many relationship between the product and order . it uses map as
	 * input takes all the products from the map for particular order and store it
	 * that table.If the products are not added in the map or map is empty then it
	 * throws exception ProductUnavailableException
	 */
	@Override
	public void insertProductIntoOrder(Order order, Map<Product, Integer> map) throws ProductUnavailableException {
		try {
			if (map.size() != 0) {
				for (Map.Entry<Product, Integer> entry : map.entrySet()) {

					Product key = entry.getKey();
					Integer value = entry.getValue();
					PreparedStatement pstmt = con
							.prepareStatement("Insert into OrderProducts(OrderId,ProductId,Quantity) values(?,?,?) ");
					pstmt.setInt(1, order.getOrderId());
					pstmt.setInt(2, key.getProductId());
					pstmt.setInt(3, value);
					pstmt.execute();
				}
			} else
				throw new ProductUnavailableException();
		} catch (SQLException ex) {
			throw new ProductUnavailableException();
		}

	}

	/*
	 * this method set the status of the order object based on three conditions if
	 * current date and orderDate difference is greater than 30 then sets the status
	 * expired if it is not within the working days then throws exception otherwise
	 * set status approve
	 */
	@Override
	public boolean approveOrder(Order order) throws InvalidOrderDateException {

		try {
			PreparedStatement pstmt1 = con.prepareStatement("Select OrderDate from Orders where OrderId = ?");
			PreparedStatement pstmt2 = con.prepareStatement("Update Orders set Status=? where OrderId=?");
			pstmt1.setInt(1, order.getOrderId());
			pstmt2.setInt(2, order.getOrderId());
			ResultSet rs = pstmt1.executeQuery();
			java.sql.Date targetSQLDate;
			if (rs.next()) {
				targetSQLDate = rs.getDate(1);
			} else
				throw new InvalidOrderDateException();
			Date currentDate = new Date(); // Current date and time
			Date targetDate = new Date(targetSQLDate.getTime());
			// Calculate the difference in milliseconds
			long differenceInMillis = currentDate.getTime() - targetDate.getTime();
			// Convert milliseconds to days
			long differenceInDays = TimeUnit.MILLISECONDS.toDays(differenceInMillis);
			if (differenceInDays > 30) {
				order.setStatus("Expired");
				pstmt2.setString(1, order.getStatus());
				pstmt2.executeUpdate();
				return false;
			} else if (!isWithinWorkingDays(currentDate, targetDate, 3)) {
				throw new InvalidOrderDateException();
			} else {
				order.setStatus("Approved");
				pstmt2.setString(1, order.getStatus());
				pstmt2.executeUpdate();
				return true;
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			throw new InvalidOrderDateException();
		}
	}

	/*
	 * this method calculates the shipping cost if totalordervalue is greater than
	 * 100000 then there is no shipping cost hence returns 0.0 but id it is less
	 * than that then based catregory of the each product in the
	 * hashmap(productList) it will calculate shipping cost for level1((price > 0 && price<= 10000)) = 5% of
	 * product price for level2(price > 10000 && price<=40000) = 3% of product price for level3 = 2% of product
	 * price.
	 * we have assigned the levels based on the prices
	 */
	@Override
	public double calculateShippingCost(Order order) throws InvalidOrderDetailException {

		if (order.getTotalOrderValue() < 100000) {
			for (Map.Entry<Product, Integer> entry : productList.entrySet()) {
				Product product = entry.getKey();
				if (product.getCategory().getProductCategoryType().equals("Level1"))
					this.shippingCost += (0.05 * product.getPrice());
				else if (product.getCategory().getProductCategoryType().equals("Level2"))
					this.shippingCost += (0.03 * product.getPrice());
				else if (product.getCategory().getProductCategoryType().equals("Level3"))
					this.shippingCost += (0.02 * product.getPrice());
			}
			order.setShippingCost(this.shippingCost);
			return shippingCost;
		} else {
			return 0.0;
		}
	}

	/*
	 * this methods checks weather the orderdate is valid or not checks the current
	 * date and +3 working days(Monday to friday)
	 */
	public static boolean isWithinWorkingDays(Date currentDate, Date targetDate, int numWorkingDays) {
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(targetDate);
		int workingDays = 0;
		while (workingDays < numWorkingDays) {
			// Check if the current date is not a weekend (Saturday or Sunday)
			int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
			if (dayOfWeek != Calendar.SATURDAY && dayOfWeek != Calendar.SUNDAY) {
				workingDays++;
			}
			// Move to the next day
			calendar.add(Calendar.DAY_OF_MONTH, 1);
		}
		// Check if the target date is within the specified number of working days
		return !currentDate.after(calendar.getTime());
	}

	/*
	 * The total value is sum of the totalOrderValue and shippingcost
	 */
	@Override
	public double calculateTotalOrderValue(Order order) throws InvalidOrderDetailException {
		order.setTotalOrderValue(this.totalOrderValue + this.shippingCost);
		return this.totalOrderValue + this.shippingCost;
	}

	@Override
	public void close() throws Exception {
		// TODO Auto-generated method stub

	}

}
